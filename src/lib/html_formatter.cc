#include "config.h"

#include <nmtkit/html_formatter.h>

#include <algorithm>
#include <regex>
#include <boost/format.hpp>
#include <nmtkit/exception.h>

using namespace std;

namespace {

// Excapes given text.
string escape(const string & text) {
  string result = regex_replace(text, regex(R"(&)"), "&amp;");
  result = regex_replace(result, regex(R"(<)"), "&lt;");
  result = regex_replace(result, regex(R"(>)"), "&gt;");
  return regex_replace(result, regex(R"(")"), "&quot;");
}

// Computes background color of the attention matrix.
string attenBGColor(float prob) {
  const int col = min(255, max(0, static_cast<int>(256.0 * prob)));
  return (boost::format("#%02x%02x%02x") % col % col % col).str();
}

// Computes foreground color of the attention matrix.
string attenFGColor(float prob) {
  return ::attenBGColor(prob >= 0.5f ? 0.0f : prob + 0.5f);
}

}  // namespace

namespace nmtkit {

HTMLFormatter::HTMLFormatter() : num_output_(0) {}

void HTMLFormatter::initialize(std::ostream * os) {
  *os << R"(
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<title>Translation Results</title>
<style type="text/css">
* {
  margin: 0;
  padding: 0;
  background: inherit;
  color: #000;
  font-size: 16px;
  font-weight: normal;
}
section {
  margin: 10px;
  padding: 10px;
  background: #def;
  border: solid 1px #445;
}
h1 {
  margin: 10x;
  padding: 10px;
  font-size: 32px;
}
h2 {
  margin: 6px 0;
  font-size: 24px;
}
p {
  margin: 4px 0;
}
table {
  border-collapse: collapse;
}
th {
  padding: 8px;
  border: solid 1px #000;
  text-align: center;
  vertical-align: middle;
}
td {
  padding: 8px;
  border: solid 1px #000;
  text-align: center;
  vertical-align: middle;
}
.word {
  display: inline-block;
  margin: 0 3px;
  padding: 4px 6px;
  background: #ddd;
  border: solid 1px #666;
  border-radius: 4px;
}
</style>
</head>
<body>
<header><h1>Translation Results</h1></header>
<article>
)";
}

void HTMLFormatter::finalize(std::ostream * os) {
  *os << R"(
</article>
<footer><p>This document is generated by <a href="https://github.com/odashi/nmtkit">NMTKit</a>.</p></footer>
</body>
</html>
)";
}

void HTMLFormatter::write(
    const string & source_line,
    const InferenceGraph & ig,
    const Vocabulary & source_vocab,
    const Vocabulary & target_vocab,
    std::ostream * os) {
  const unsigned bos_id = target_vocab.getID("<s>");
  const unsigned eos_id = target_vocab.getID("</s>");

  // Note: this formatter outputs only the one-best result.
  auto nodes = ig.findOneBestPath(bos_id, eos_id);

  // Retrieves actual input words.
  vector<string> actual_source_words;
  for (const unsigned id : source_vocab.convertToIDs(source_line)) {
    actual_source_words.emplace_back(source_vocab.getWord(id));
  }

  // Outputs HTML.
  *os << "<section>\n";
  *os << "<h2>Sentence " << (num_output_ + 1) << "</h2>\n";

  *os << "<p>Raw input line: <span class=\"word\">"
      << source_line
      << "</span></p>\n";

  *os << "<p>Actual input words: ";
  for (const string & w : actual_source_words) {
    *os << "<span class=\"word\">" << ::escape(w) << "</span>";
  }
  *os << "</p>\n";

  *os << "<p>Output words: ";
  for (unsigned i = 1; i < nodes.size() - 1; ++i) {
    const nmtkit::InferenceGraph::Label & label = nodes[i]->label();
    *os << "<span class=\"word\">"
        << ::escape(target_vocab.getWord(label.word_id))
        << "</span>";
  }
  *os << "</p>\n";

  *os << "<p>Log probabilities:</p>\n";
  *os << "<table>\n";
  for (unsigned i = 1; i < nodes.size(); ++i) {
    const nmtkit::InferenceGraph::Label & label = nodes[i]->label();
    *os << "<tr><td>"
        << ::escape(target_vocab.getWord(label.word_id))
        << "</td><td>"
        << label.word_log_prob
        << "</td></tr>\n";
  }
  *os << "</table>\n";

  *os << "<p>Attention:</p>\n";
  *os << "<table>\n";
  *os << "<tr><td></td><td>&lt;s&gt;</td>";
  for (const string & w : actual_source_words) {
    *os << "<td>" << ::escape(w) << "</td>";
  }
  *os << "<td>&lt;/s&gt;</td></tr>\n";
  for (unsigned i = 1; i < nodes.size(); ++i) {
    const nmtkit::InferenceGraph::Label & label = nodes[i]->label();
    *os << "<tr><td>"
        << ::escape(target_vocab.getWord(label.word_id))
        << "</td>";
    for (const float atten : label.atten_probs) {
      *os << "<td style=\"background: "
          << attenBGColor(atten)
          << "; color: "
          << attenFGColor(atten)
          << ";\">"
          << (boost::format("%.2f") % atten)
          << "</td>";
    }
    *os << "</tr>\n";
  }
  *os << "</table>";

  *os << "</section>\n";

  ++num_output_;
}

}  // namespace nmtkit
