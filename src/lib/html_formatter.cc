#include <nmtkit/html_formatter.h>

#include <algorithm>
#include <regex>
#include <boost/format.hpp>
#include <nmtkit/exception.h>

using namespace std;

namespace {

// Excapes given text.
string escape(const string & text) {
  string result = regex_replace(text, regex(R"(&)"), "&amp;");
  result = regex_replace(result, regex(R"(<)"), "&lt;");
  result = regex_replace(result, regex(R"(>)"), "&gt;");
  return regex_replace(result, regex(R"(")"), "&quot;");
}

// Computes attention color.
string attentionColor(float prob) {
  const string ids = "0123456789abcdef";
  const int color = min(15, max(0, static_cast<int>(16.0 * prob)));
  return string("#") + ids[color] + ids[color] + ids[color];
}

}  // namespace

namespace nmtkit {

HTMLFormatter::HTMLFormatter() : num_output_(0) {}

void HTMLFormatter::initialize(std::ostream * os) {
  *os << R"(
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<title>Translation Results</title>
<style type="text/css">
* {
  margin: 0;
  padding: 0;
  background: inherit;
  color: #000;
  font-size: 16px;
  font-weight: normal;
}
section {
  margin: 10px;
  padding: 10px;
  background: #def;
  border: solid 1px #445;
}
h1 {
  margin: 10x;
  padding: 10px;
  font-size: 32px;
}
h2 {
  margin: 6px 0;
  font-size: 24px;
}
p {
  margin: 4px 0;
}
table {
  border-collapse: collapse;
}
th {
  padding: 8px;
  border: solid 1px #555;
  text-align: center;
  vertical-align: middle;
}
td {
  padding: 8px;
  border: solid 1px #555;
  text-align: center;
  vertical-align: middle;
}
.word {
  display: inline-block;
  margin: 0 2px;
  padding: 4px 6px;
  background: #ddd;
  border: solid 1px #555;
  border-radius: 4px;
}
</style>
</head>
<body>
<header><h1>Translation Results</h1></header>
<article>
)";
}

void HTMLFormatter::finalize(std::ostream * os) {
  *os << R"(
</article>
<footer><p>This document is generated by <a href="https://github.com/odashi/nmtkit">NMTKit</a>.</p></footer>
</body>
</html>
)";
}

void HTMLFormatter::write(
    const vector<string> & source_words,
    const InferenceGraph & ig,
    const Vocabulary & source_vocab,
    const Vocabulary & target_vocab,
    std::ostream * os) {
  const unsigned bos_id = target_vocab.getID("<s>");
  const unsigned eos_id = target_vocab.getID("</s>");

  // Note: this formatter outputs only the one-best result.
  
  // Finds the one-best path.
  vector<const nmtkit::InferenceGraph::Node *> nodes;
  ig.findNodes(&nodes, [&](const nmtkit::InferenceGraph::Node & node) {
      return node.label().word_id == bos_id;
  });
  NMTKIT_CHECK_EQ(
      1, nodes.size(), "No or multiple '<s>' nodes in the inference graph.");
  while (nodes.back()->label().word_id != eos_id) {
    // Finds the most accurate word.
    const nmtkit::InferenceGraph::Node * cur_node = nodes.back();
    NMTKIT_CHECK(!cur_node->next().empty(), "No next node of the current node");
    const nmtkit::InferenceGraph::Node * best_node = nullptr;
    float best_log_prob = -1e100;
    for (const auto next_node : cur_node->next()) {
      if (next_node->label().word_log_prob > best_log_prob) {
        best_node = next_node;
        best_log_prob = next_node->label().word_log_prob;
      }
    }
    nodes.emplace_back(best_node);
  }

  // Retrieves actual input words.
  vector<string> actual_source_words;
  for (const string & w : source_words) {
    actual_source_words.emplace_back(
        source_vocab.getWord(source_vocab.getID(w)));
  }

  // Outputs HTML.
  *os << "<section>\n";
  *os << "<h2>Sentence " << (num_output_ + 1) << "</h2>\n";

  *os << "<p>Raw input words: ";
  for (const string & w : source_words) {
    *os << "<span class=\"word\">" << ::escape(w) << "</span>";
  }
  *os << "</p>\n";
  
  *os << "<p>Actual input words: ";
  for (const string & w : actual_source_words) {
    *os << "<span class=\"word\">" << ::escape(w) << "</span>";
  }
  *os << "</p>\n";

  *os << "<p>Output words: ";
  for (unsigned i = 1; i < nodes.size() - 1; ++i) {
    const nmtkit::InferenceGraph::Label & label = nodes[i]->label();
    *os << "<span class=\"word\">"
        << ::escape(target_vocab.getWord(label.word_id))
        << "</span>";
  }
  *os << "</p>\n";

  *os << "<p>Log probabilities:</p>\n";
  *os << "<table>\n";
  for (unsigned i = 1; i < nodes.size(); ++i) {
    const nmtkit::InferenceGraph::Label & label = nodes[i]->label();
    *os << "<tr><td>"
        << ::escape(target_vocab.getWord(label.word_id))
        << "</td><td>"
        << label.word_log_prob
        << "</td></tr>\n";
  }
  *os << "</table>\n";

  *os << "<p>Attention:</p>\n";
  *os << "<table>\n";
  *os << "<tr><td></td><td>&lt;s&gt;</td>";
  for (const string & w : actual_source_words) {
    *os << "<td>" << ::escape(w) << "</td>";
  }
  *os << "<td>&lt;/s&gt;</td></tr>\n";
  for (unsigned i = 1; i < nodes.size(); ++i) {
    const nmtkit::InferenceGraph::Label & label = nodes[i]->label();
    *os << "<tr><td>"
        << ::escape(target_vocab.getWord(label.word_id))
        << "</td>";
    for (const float atten : label.atten_probs) {
      *os << "<td style=\"background: " << attentionColor(atten) << "\">"
          << (boost::format("%.2f") % atten)
          << "</td>";
    }
    *os << "</tr>\n";
  }
  *os << "</table>";

  *os << "</section>\n";

  ++num_output_;
}

}  // namespace nmtkit
